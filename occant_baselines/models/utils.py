#!/usr/bin/env python3

# Copyright (c) Facebook, Inc. and its affiliates.
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

import torch
import torch.nn.functional as F

from einops import repeat


def crop_map(h, x, crop_size, mode="bilinear"):
    r"""
    Crops a tensor h centered around location x with size crop_size

    Inputs:
        h - (bs, F, H, W)
        x - (bs, 2) --- (x, y) locations
        crop_size - scalar integer

    Conventions for x:
        The origin is at the top-left, X is rightward, and Y is downward.
    """

    bs, _, H, W = h.size()
    Hby2 = (H - 1) / 2 if H % 2 == 1 else H // 2
    Wby2 = (W - 1) / 2 if W % 2 == 1 else W // 2
    start = -(crop_size - 1) / 2 if crop_size % 2 == 1 else -(crop_size // 2)
    end = start + crop_size - 1
    x_grid = repeat(
        torch.arange(start, end + 1, step=1), "w -> h w", h=crop_size
    ).float()
    y_grid = repeat(
        torch.arange(start, end + 1, step=1), "h -> h w", w=crop_size
    ).float()
    center_grid = torch.stack([x_grid, y_grid], dim=2).to(
        h.device
    )  # (crop_size, crop_size, 2)

    x_pos = x[:, 0] - Wby2  # (bs, )
    y_pos = x[:, 1] - Hby2  # (bs, )

    crop_grid = repeat(center_grid, "h w 2 -> b h w 2", b=bs)

    # Convert the grid to (-1, 1) range
    crop_grid[:, :, :, 0] = (
                                    crop_grid[:, :, :, 0] + x_pos.unsqueeze(1).unsqueeze(2)
                            ) / Wby2
    crop_grid[:, :, :, 1] = (
                                    crop_grid[:, :, :, 1] + y_pos.unsqueeze(1).unsqueeze(2)
                            ) / Hby2

    h_cropped = F.grid_sample(h, crop_grid, mode=mode)

    return h_cropped
